#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  frontRightE,    sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           arm,           tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           backLeft,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           frontRight,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           backRight,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           armRight,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           ShootmotorLeft, tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           ShootmotorRight, tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           ShootmotorTop, tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port10,          armLeft,       tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"

// Include the lcd button get utility function
// Include my coding functions
#include "getlcdbuttons.c"
#include "MechWheelFunctions.c"

// Update inteval (in mS) for the flywheel control loop
#define FW_LOOP_SPEED              25

// Maximum power we want to send to the flywheel motors
#define FW_MAX_POWER              127

// encoder counts per revolution depending on motor
#define MOTOR_TPR_269           240.448
#define MOTOR_TPR_393R          261.333
#define MOTOR_TPR_393S          392
#define MOTOR_TPR_393T          627.2
#define MOTOR_TPR_QUAD          360.0


//definition of menus and global variables for autonomous selection
typedef enum _vexAlliance {
    kAllianceBlue = 0,
    kAllianceRed
} vexAlliance;

typedef enum _vexStartposition {
    kStartHanging = 0,
    kStartMiddle
} vexStartposition;

typedef enum _vexLcdMenus {
    kMenuStart    = 0,

    kMenuAlliance = 0,
    kMenuStartpos,
    kMenuAutonSelect,

    kMenuMax
} vexLcdMenus;

static  vexAlliance         vAlliance = kAllianceBlue;
static  vexStartposition    vPosition = kStartHanging;
static  short               vAuton = 0;
int buttonToggleState = 0;
int buttonPressed = 0;

//Display menus + selections
void
LcdAutonomousDisplay( vexLcdMenus menu )
{
    // Clear the lcd
    clearLCDLine(0);
    clearLCDLine(1);

    // Selection arrows
    displayLCDString(1,  0, l_arr_str);
    displayLCDString(1, 13, r_arr_str);
    displayLCDString(1,  5, "CHANGE");

    // Autonomous names
    switch( menu ) {
        case    kMenuAlliance:
            if( vAlliance == kAllianceBlue )
                displayLCDString(0, 0, "Alliance - BLUE");
            else
                displayLCDString(0, 0, "Alliance - RED");
            break;
        case    kMenuStartpos:
            if( vPosition == kStartHanging )
                displayLCDString(0, 0, "Start - Left");
            else
                displayLCDString(0, 0, "Start - Right");
            break;
        case    kMenuAutonSelect:
            switch( vAuton ) {
                case    0:
                    displayLCDString(0, 0, "Default");
                    break;
                case    1:
                    displayLCDString(0, 0, "Only Park");
                    break;
                default:
                    char    str[20];
                    sprintf(str,"Undefined %d", vAuton );
                    displayLCDString(0, 0, str);
                    break;
                }
            break;

        default:
            displayLCDString(0, 0, "Unknown");
            break;
        }
}

//Rotate through menus
void
LcdAutonomousSelection()
{
    TControllerButtons  button;
    vexLcdMenus  menu = kMenuStart;

		//backlight

    bLCDBacklight = true;

    //display default choice
    LcdAutonomousDisplay(0);

    while( bIfiRobotDisabled )
        {
        //function blocks until button is pressed
        button = getLcdButtons();

        // display + select autonomous routine
        if( ( button == kButtonLeft ) || ( button == kButtonRight ) ) {
            // previous choice
            if( button == kButtonLeft )
                if( --menu < kMenuStart ) menu = kMenuMax-1;
            // next choice
            if( button == kButtonRight )
                if( ++menu >= kMenuMax ) menu = kMenuStart;
            }

        // Select choice for menu
        if( button == kButtonCenter )
            {
            switch( menu ) {
                case    kMenuAlliance:
                    // alliance color
                    vAlliance = (vAlliance == kAllianceBlue) ? kAllianceRed : kAllianceBlue;
                    break;
                case    kMenuStartpos:
                    // start position
                    vPosition = (vPosition == kStartHanging) ? kStartMiddle : kStartHanging;
                    break;
                case    kMenuAutonSelect:
                    // autonomous routine for specific position + color
                    if( ++vAuton == 3 )
                        vAuton = 0;
                    break;
                }

            }

				//display again
        LcdAutonomousDisplay(menu);
				//Stop cpu hog
        wait1Msec(10);
        }




}

//Display Status during driver and autonomous

void
LcdDisplayStatus( long enabledTime )

{
    string str;

    sprintf(str,"VBatt %7.2f   ", nAvgBatteryLevel/1000.0 );
    displayLCDString(0, 0, str);
    if( bIfiAutonomousMode )
        sprintf(str, "Autonomous %.2f", (nPgmTime-enabledTime)/1000.0);
    else
        sprintf(str, "Driver     %.2f", (nPgmTime-enabledTime)/1000.0);
    displayLCDString(1, 0, str);
}

//This task replaces the default competition control
//It is started during pre_auton() and does not terminate
//pre_auton also does not return and run the remaining code in the "main"
//task that is part of Vex_Competition_Includes.c                                                                                                         */
//This task does not stop other tasks when the robot is disable, that's up
//to the user to modify and add, using allTasksStop() is not recommended as
//it will also stop this task, allTasksStop stops everything except main

task mainTask()
{
    long    enabledTime;
    while( true )
        {
        //when disabled, run the autonomous selector
        if( bIfiRobotDisabled )
            LcdAutonomousSelection();
        else
            {
            //time robot was enabled
            enabledTime = nPgmTime;

            //when enabled run either autonomous or user control
            if (bIfiAutonomousMode)
                {
                startTask(autonomous);

                // Wait for auto phase to end
                while (bIfiAutonomousMode && !bIfiRobotDisabled) {
                    if (!bVEXNETActive) {
                        if (nVexRCReceiveState == vrNoXmiters)
                            allMotorsOff();
                        }

                    // Display status
                    LcdDisplayStatus(enabledTime);

                    // Wait for autonomous to end
                    wait1Msec(25);
                    }

                allMotorsOff();

                // Stop other tasks here

                stopTask(autonomous);
                }
            else
                {
                startTask(usercontrol);
                // Repeat loop waiting for user control to end and start
                // of a new competition run
                while (!bIfiAutonomousMode && !bIfiRobotDisabled) {
                    if (nVexRCReceiveState == vrNoXmiters) //transmiters off
                        allMotorsOff();

                    // Display status (user control)
                    LcdDisplayStatus(enabledTime);

                    wait1Msec(25);
                    }

                allMotorsOff();

                // Stop tasks
                stopTask(usercontrol);
                }
            }
        }
}

// The pre_auton function does not return, "normal competition control" is disabled
void pre_auton()
{
    startTask( mainTask );


    while(1) wait1Msec(1000);
}

void
autonomousRed()
{
    if( vPosition == kStartHanging ) { //left
        switch( vAuton ) {
            case    0:
//get ball from under cap
leftSpin(52, 925);
bottomintake(250, 127);
topintake(160, 127);
//return back to starting position
rightSpin(52, 430);
//start flywheel
motor[ShootmotorLeft] = 127;
motor[ShootmotorRight] = 127;
motor[ShootmotorTop] = 127;
rightSpin(52, 556);
//turn 90 degrees
forwardFour(52, 326);
//go forward half + shoot high flag
leftSpin(52,169);
bottomintake(250,127);
topintake(250, 127);
//go forwad 3/4 + shoot middle flag
leftSpin(52,574);
bottomintake(790,127);
topintake(790,127);
//go forward hit bottom flag
leftSpin(52, 241);
//stop flywheel
motor[ShootmotorLeft] = 0;
motor[ShootmotorRight] = 0;
motor[ShootmotorTop] = 0;
//go backward
rightSpin(52, 457);
//turn 90 degrees
backwardFour(52, 88);
//outtake flip cap
motor[armLeft] = 106;
//go forward
leftSpin(106, 583);
//back off
rightSpin(52, 322);
//backwards bump into wall
rightSpin(52, 575);
//forward bounce off wall
leftSpin (52, 187);
//turn right 90 degrees
backwardFour(52, 349);
//forward to platform
leftSpin(52, 1222);
//turn left 90 degrees
forwardFour(52, 169);
//forward hit wall
rightSpin(52, 259);
motor[armLeft] = -127;
motor[armRight] = 127;
//backward bounce of wall
leftSpin (52, 52);
//backward full power go up to platform
leftSpin (127, 1330);
//backward full power
leftSpin(127, 709);


//forwardFour(30,60);
//rightSpin(40,1330);
//backwardFour(30,187);
//rightSpin(127,232);
//leftSpin(127,2500);

//motor[ShootmotorLeft] = 127;
//motor[ShootmotorRight] = 127;
//motor[ShootmotorTop] = 127;
//leftSpin(70,600);
//rightSpin(40,232);
//forwardFour(15,70);
//bottomintake(1000,127);
//rightSpin(30,60);
//backwardFour(40,1330);
//leftSpin(30,493);
//backwardFour(127,232);
//forwardFour(127,2500);

                break;
            case    1: //skills challenge
//get ball from under cap
leftSpin(52, 925);
bottomintake(250, 127);
topintake(160, 127);
//return back to starting position
rightSpin(52, 430);
//start flywheel
motor[ShootmotorLeft] = 127;
motor[ShootmotorRight] = 127;
motor[ShootmotorTop] = 127;
rightSpin(52, 556);
//turn 90 degrees
forwardFour(52, 320);
//go forward half + shoot high flag
leftSpin(52,169);
bottomintake(250,127);
topintake(250, 127);
//go forwad 3/4 + shoot middle flag
leftSpin(52,574);
bottomintake(790,127);
topintake(790,127);
//go forward hit bottom flag
leftSpin(52, 241);
//stop flywheel
motor[ShootmotorLeft] = 0;
motor[ShootmotorRight] = 0;
motor[ShootmotorTop] = 0;
//go backward
rightSpin(52, 457);
//turn 90 degrees
backwardFour(52, 88);
//outtake flip cap
motor[armLeft] = 106;
//go forward
leftSpin(106, 583);
//back off
rightSpin(52, 322);
//backwards bump into wall
rightSpin(52, 575);
//forward bounce off wall
leftSpin (52, 187);
//turn right 90 degrees
backwardFour(52, 349);
//forward to platform
leftSpin(52, 1222);
//turn left 90 degrees
forwardFour(52, 169);
//forward hit wall
rightSpin(52, 259);
motor[armLeft] = -127;
motor[armRight] = 127;
//backward bounce of wall
leftSpin (52, 52);
//backward full power go up to platform
leftSpin (127, 1627);
//backward full power
leftSpin(127, 709);
                break;
            default:
                break;
        }
}
    else { 														// right
        switch( vAuton ) {
            case    0:
//rightSpin(127, 844);
//intakein(300, 127);
//leftSpin(127, 300);

                break;
            case    1:
                // run some other autonomous code
                break;
            default:
                break;
        }
    }
}

void
autonomousBlue()
{
    if( vPosition == kStartHanging ) { //left
        switch( vAuton ) {
            case    0:
//get ball from under cap
leftSpin(127, 1024);
bottomintake(160, 127);
topintake(160, 127);
//return back to starting pos
rightSpin(127, 322);

                break;
            case    1:
                // run some other autonomous code
                break;
            default:
                break;
        }
    }
    else { 													   // right
        switch( vAuton ) {
            case    0:
//get ball from under cap
leftSpin(127, 1024);
bottomintake(160, 127);
topintake(160, 127);
//return back to starting pos
rightSpin(127, 322);
//start flywheel
motor[ShootmotorLeft] = 127;
motor[ShootmotorRight] = 127;
motor[ShootmotorTop] = 127;
rightSpin(115, 853);
//bounce forward
leftSpin(61, 16);
//turn 90 degrees
backwardFour(52, 376);
//go forward half + shoot high flag
leftSpin(52,358);
bottomintake(250,127);
topintake(250, 127);
//go fowrad 3/4 + shoot middle flag
leftSpin(70,484);
bottomintake(790,127);
topintake(790,127);
//go forward hit bottom flag
leftSpin(61, 196);
//go backward
rightSpin(70, 457);
//turn 90 degrees
forwardFour(52, 349);
//outtake flip cap
motor[armLeft] = 106;
//go forward
leftSpin(106, 520);
//back off
rightSpin(127, 250);
//backwards bump into wall
rightSpin(127, 790);
//forward bounce off wall
leftSpin (79, 79);
//turn left 90 degrees
forwardFour(52, 146);
//forward to platform
leftSpin(97, 799);
//turn right 90 degrees
backwardFour(52, 367);
//forward hit wall
rightSpin(127, 349);
//backward bounce of wall
leftSpin (79, 52);
//backward full power go up to platform
leftSpin (127, 1366);
//backward full power
leftSpin(127, 502);

                break;
            case    1:
                // run some other autonomous code
                break;
            default:
                break;
        }
    }
}

task autonomous()
{
    if( vAlliance == kAllianceBlue )
    {
    	//start ball shooter
        autonomousBlue();

}
    else{
    	//start ball shooter
        autonomousRed();

}
}

// switching joystick power
task usercontrol()
{

bLCDBacklight = true;

int power = 0;
  while (true) {

//40% power
  if (vexRT[Btn8RXmtr2] == 1)
  {
		power = 1;
}


//0% power
	if (vexRT[Btn8UXmtr2] == 1)
	{
		power = 4;
}

//switch for power

switch(power)
{
 case 1: //40% power
 		motor[frontLeft]= vexRT[Ch2]*-51/127;
		motor[backLeft]= vexRT[Ch2]*-51/127;
		motor[backRight]= vexRT[Ch3]*51/127;
		motor[frontRight]= vexRT[Ch3]*51/127;
		power=0;
 break;

 case 4: //0% power
 		motor[frontLeft]= vexRT[Ch2]*1/127;
		motor[backLeft]= vexRT[Ch2]*1/127;
		motor[backRight]= vexRT[Ch3]*1/127;
		motor[frontRight]= vexRT[Ch3]*1/127;
		power=0;
 break;

 default: //default: 100% power
  	motor[frontLeft]= vexRT[Ch3]*-127/127;
		motor[backLeft]= vexRT[Ch3]*-127/127;
		motor[backRight]= vexRT[Ch2]*127/127;
		motor[frontRight]= vexRT[Ch2]*127/127;
}

//no power change controls
 //	motor[frontLeft]= vexRT[Ch2];
	//motor[backLeft]= vexRT[Ch2];
	//	motor[backRight]= vexRT[Ch3];
	//	motor[frontRight]= vexRT[Ch3];


//// Different speeds set by buttons
//   if( vexRT[ Btn7UXmtr2] == 1 )
//       FwVelocitySet( 144, 0.55 );
//   if( vexRT[ Btn7LXmtr2 ] == 1 )
//       FwVelocitySet( 120, 0.38 );
//   if( vexRT[ Btn7RXmtr2 ] == 1 )
//       FwVelocitySet( 50, 0.2 );
//   if( vexRT[ Btn7DXmtr2 ] == 1 )
//       FwVelocitySet( 00, 0 );

//Bottom Intake
	if(vexRT[Btn5U] == 1)
		{
		motor[armLeft] = 127;
}
	else if (vexRT [Btn5D] == 1)
		{
	motor[armLeft] = -127;
}
	else
{
	motor[armLeft] = 0;
}

//Top Intake
  if(vexRT[Btn5DXmtr2] == 1)
  {
  	motor[armRight] = -127;
  }
  else if (vexRT [Btn5UXmtr2] == 1)
  {
  	motor[armRight] = 127;
  }
  else
  {
  	motor[armRight] = 0;
  }

//Descore
	if(vexRT[Btn6U] == 1)
		{
		motor[arm] = -127;
}
	else if (vexRT[Btn6D] ==1){
		motor[arm] = 127;
}
		else {
			motor[arm] = 0;
}

//Flywheel Toggle
  if(vexRT[Btn6UXmtr2] == 1 )
  {
  if( ! buttonPressed )
  {
    buttonToggleState = 1 - buttonToggleState;
    buttonPressed = 1;
  }
}
  else
  {
    buttonPressed = 0;
  }

  if( buttonToggleState )
  {
    motor[ShootmotorLeft] = 100;
    motor[ShootmotorRight] = 100;
   	motor[ShootmotorTop] = 100;
  }
  else
  {
    motor[ShootmotorLeft] = 0;
    motor[ShootmotorRight] = 0;
   	motor[ShootmotorTop] = 0;
  }

}
}
